<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | 丁家明的个人博客</title><meta name="author" content="丁家明"><meta name="copyright" content="丁家明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构绪论基本概念数据结构学科：一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作相关问题的学科 数据：描述客观事物的符号 数据元素：组成数据的，有一定意义的基本单位 数据项：一个数据元素由若干数据项组成(最小单位) 数据对象：相同数据元素的集合 数据结构：相互存在一种或多种特定关系的数据元素集合   逻辑结构：数据对象中数据元素之间的相互关系 集合结构：数据元素属于统一集合">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://0science.github.io/Hexo/2023/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="丁家明的个人博客">
<meta property="og:description" content="数据结构绪论基本概念数据结构学科：一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作相关问题的学科 数据：描述客观事物的符号 数据元素：组成数据的，有一定意义的基本单位 数据项：一个数据元素由若干数据项组成(最小单位) 数据对象：相同数据元素的集合 数据结构：相互存在一种或多种特定关系的数据元素集合   逻辑结构：数据对象中数据元素之间的相互关系 集合结构：数据元素属于统一集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://0science.github.io/Hexo/img/photo.jpg">
<meta property="article:published_time" content="2023-08-19T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-27T07:54:30.631Z">
<meta property="article:author" content="丁家明">
<meta property="article:tag" content="IT">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0science.github.io/Hexo/img/photo.jpg"><link rel="shortcut icon" href="/Hexo/img/photo.jpg"><link rel="canonical" href="https://0science.github.io/Hexo/2023/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/Hexo/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/Hexo/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-27 15:54:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Hexo/img/photo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/Hexo/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/Hexo/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/Hexo/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Hexo/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Hexo/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Hexo/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Hexo/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Hexo/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Hexo/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Hexo/games/"><i class="fa-fw fas fa-games"></i><span> 游戏</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/Hexo/img/BingWallpaper.jpg')"><nav id="nav"><span id="blog-info"><a href="/Hexo/" title="丁家明的个人博客"><span class="site-name">丁家明的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Hexo/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Hexo/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Hexo/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Hexo/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Hexo/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Hexo/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Hexo/games/"><i class="fa-fw fas fa-games"></i><span> 游戏</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T16:00:00.000Z" title="发表于 2023-08-20 00:00:00">2023-08-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-27T07:54:30.631Z" title="更新于 2023-08-27 15:54:30">2023-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Hexo/categories/%E6%95%99%E7%A8%8B/">教程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Hexo/categories/%E6%95%99%E7%A8%8B/408/">408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>数据结构学科</strong>：一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作相关问题的学科</p>
<p><strong>数据</strong>：描述客观事物的符号</p>
<p><strong>数据元素</strong>：组成数据的，有一定意义的基本单位</p>
<p><strong>数据项</strong>：一个数据元素由若干数据项组成(<strong>最小单位</strong>)</p>
<p><strong>数据对象</strong>：相同数据元素的集合</p>
<p><strong>数据结构</strong>：相互存在一种或多种特定关系的数据元素集合</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307280951600.png" height=250 /></center>

<p><strong>逻辑结构</strong>：数据对象中数据元素之间的相互关系</p>
<p><strong>集合结构</strong>：数据元素属于统一集合</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307280956448.jpg" height=200 /></center>

<p><strong>线性结构</strong>：数据元素间是一对一的关系</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307280956966.jpg" height=200 /></center>

<p><strong>树形结构</strong>：数据元素间是一对多的关系</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307281008188.png" height=200 /></center>

<p><strong>图形结构</strong>：数据元素间是多对多的关系</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307281009776.png" height=250 /></center>

<p><strong>物理结构</strong>：计算机中的存储形式</p>
<p><strong>顺序存储结构</strong>：将数据元素存放在地址连续的存储单元里</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307281016277.png" height=60 /></center>

<p><strong>链式存储结构</strong>：将数据元素存放在任意的存储单元里</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307281016084.png" height=250 /></center>

<p><strong>数据类型</strong>：一组性质相同的值的集合及定义在此集合上的一些操作</p>
<p><strong>原子类型</strong>：不可再分解的基本类型</p>
<p><strong>结构类型</strong>：由若干个类型组合而成，可再分解</p>
<p><strong>抽象</strong>：提取出事物具有的普遍性质</p>
<p><strong>抽象数据类型</strong>：一个数学模型及定义在该模型上的一组操作</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>算法</strong>：解决特定问题求解步骤的描述</p>
<p><strong>算法的特性</strong>：</p>
<ol>
<li><strong>输入输出</strong>：算法可以没有输入，但至少有一个输出</li>
<li><strong>有穷性</strong>：算法在执行有限步骤后会自动结束，每一步都在可接受的时间内完成</li>
<li><strong>确定性</strong>：算法的每一步都有确定的含义</li>
<li><strong>可行性</strong>：算法的每一步都可执行，每一步都能在有限执行次数内完成</li>
</ol>
<p><strong>算法的要求</strong>：</p>
<ol>
<li><strong>正确性</strong>：无歧义，正确得到答案，正确反应需求</li>
<li><strong>可读性</strong>：方便阅读、交流和理解</li>
<li><strong>健壮性</strong>：输入不合法时，能做出相关处理</li>
<li><strong>时间效率高</strong></li>
<li><strong>低存储需求</strong></li>
</ol>
<p><strong>算法的效率度量</strong>：</p>
<ol>
<li><strong>事后统计法</strong>：通过设计好的程序和数据，比较运行时间</li>
<li><strong>事前估计法</strong>：编程前估计算法输入规模</li>
<li><strong>输入规模</strong>：输入量的多少</li>
</ol>
<p><strong>算法的复杂度</strong>：</p>
<ol>
<li><strong>时间复杂度</strong>：算法执行时间的增长率随问题规模变化的函数</li>
<li><strong>空间复杂度</strong>：算法执行空间的增长率随问题规模变化的函数</li>
</ol>
<p><strong>大O记法</strong>：用大写的O()表示时间复杂度</p>
<ol>
<li>用1取代加法常数</li>
<li>只保留最高阶</li>
<li>去除最高阶系数</li>
</ol>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307281048338.png" height=60 /></center>

<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>线性表</strong>：n个数据元素的有限序列</p>
<p><strong>表长</strong>：线性表的元素个数n</p>
<p><strong>空表</strong>：n&#x3D;0的线性表</p>
<p><strong>位序</strong>：数据元素的下标</p>
<p><strong>表头</strong>：第一个元素</p>
<p><strong>表尾</strong>：最后一个元素</p>
<p><strong>前驱</strong>：元素左侧元素</p>
<p><strong>后继</strong>：元素右侧元素</p>
<p><strong>直接前驱</strong>：元素左侧相邻元素</p>
<p><strong>直接后继</strong>：元素右侧相邻元素</p>
<blockquote>
<p>每个元素都有前驱（除表首）<br>每个元素都有后继（除表尾）</p>
</blockquote>
<p><strong>线性表的特点</strong>：</p>
<ol>
<li>元素个数有限</li>
<li>元素有先后顺序</li>
<li>每个元素都是数据元素</li>
<li>元素大小相同</li>
<li>元素具有抽象性</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">InitList(&amp;L)       \\初始化表<br>Length(L)          \\表长<br>LocalElem(L,e)     \\按值查找<br>GetElem(L,e)       \\按位查找<br>ListInsert(&amp;L,i,e) \\插入<br>ListDelete(&amp;L,i,e) \\删除<br>PrintList(L)       \\输出<br>Empty(L)           \\判空<br>DestroyList(L)     \\销毁<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/<br>void unionL(SqList *La,SqList Lb)<br>&#123;<br>	int La_len,Lb_len,i;<br>	ElemType e;                        /*声明与La和Lb相同的数据元素e*/<br>	La_len=ListLength(*La);            /*求线性表的长度 */<br>	Lb_len=ListLength(Lb);<br>	for (i=1;i&lt;=Lb_len;i++)<br>	&#123;<br>		GetElem(Lb,i,&amp;e);              /*取Lb中第i个数据元素赋给e*/<br>		if (!LocateElem(*La,e))        /*La中不存在和e相同数据元素*/<br>			ListInsert(La,++La_len,e); /*插入*/<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>顺序表</strong>：线性表的顺序存储，用一组地址连续的存储单元依次存储数据元素</p>
<p><strong>静态分配</strong>：数组大小和空间固定</p>
<p><strong>动态分配</strong>：在程序执行过程中分配空间</p>
<p><strong>地址</strong>：存储器中每个存储单元的编号</p>
<blockquote>
<p>线性表从1开始，数组从0开始<br>线性表具备三个属性：起始位置、最大容量、当前长度<br>线性表长度小于数组长度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define MAXSIZE 20          /* 存储空间初始分配量 */<br>typedef int ElemType;       /* ElemType类型根据实际情况而定，这里为int */<br>typedef struct<br>&#123;<br>	ElemType data[MAXSIZE]; /* 数组，存储数据元素 */<br>	int length;             /* 线性表当前长度 */<br>&#125;SqList;<br></code></pre></td></tr></table></figure>

<p><strong>顺序表的优缺点</strong></p>
<ol>
<li>随机访问，可直接查找特定节点</li>
<li>存储密度高</li>
<li>逻辑相邻且物理相邻</li>
<li>插入删除移动大量元素</li>
<li>造成空间碎片化</li>
</ol>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define OK 1<br>#define ERROR 0<br>/* Status是函数的类型,其值是函数结果状态代码，如OK等 */<br>typedef int Status;         <br><br>/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */<br>/* 操作结果：用e返回L中第i个数据元素的值，注意i是指位置，第1个位置的数组是从0开始 */<br>Status GetElem(SqList L,int i,ElemType *e)<br>&#123;<br>	if(L.length==0 || i&lt;1 || i&gt;L.length)<br>		return ERROR;<br>	*e=L.data[i-1];<br><br>	return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ol>
<li>插入位置不合理，则显示异常</li>
<li>线性表长度大于数组长度，则显示异常或动态增加容量</li>
<li>从最后一个元素开始向前遍历到第个元素，并将其向后移动一位</li>
<li>将元素插入该位置</li>
<li>表长加一</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */<br>/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */<br>Status ListInsert(SqList *L,int i,ElemType e)<br>&#123; <br>	int k;<br>	if (L-&gt;length==MAXSIZE)  			/* 顺序线性表已经满 */<br>		return ERROR;<br>	if (i&lt;1 || i&gt;L-&gt;length+1)			/* 当i比第一位置小或者比最后一位置后一位置还要大时 */<br>		return ERROR;				<br><br>	if (i&lt;=L-&gt;length)        			/* 若插入数据位置不在表尾 */<br>	&#123;<br>		for(k=L-&gt;length-1;k&gt;=i-1;k--)  	/* 将要插入位置后的元素向后移一位 */<br>			L-&gt;data[k+1]=L-&gt;data[k];<br>	&#125;<br>	L-&gt;data[i-1]=e;          			/* 将新元素插入 */<br>	L-&gt;length++;<br><br>	return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol>
<li>位置不合理，则显示异常</li>
<li>取出删除元素</li>
<li>从删除元素位置开始遍历到最后一个元素，并将其前移一位</li>
<li>表长减一</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */<br>/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */<br>Status ListDelete(SqList *L,int i,ElemType *e) <br>&#123; <br>	int k;<br>	if (L-&gt;length==0)               /* 线性表为空 */<br>		return ERROR;<br>	if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */<br>		return ERROR;<br>	*e=L-&gt;data[i-1];<br>	if (i&lt;L-&gt;length)                /* 如果删除不是最后位置 */<br>	&#123;<br>		for(k=i;k&lt;L-&gt;length;k++)	/* 将删除位置后继元素前移 */<br>			L-&gt;data[k-1]=L-&gt;data[k];<br>	&#125;<br>	L-&gt;length--;<br>	return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>单链表</strong>：线性表的链式存储，用任意一组存储单元存储元素</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-7.jpg" height=120 /></center>

<p><strong>头指针</strong>：链表中第一个节点的存储位置，有头结点则指向头结点(<strong>必备</strong>)</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-8.jpg" height=40 /></center>

<p><strong>头结点</strong>：单链表第一个结点前附加的一个结点</p>
<p><strong>数据域</strong>：存储信息元素的域(<strong>p-&gt;data</strong>)</p>
<p><strong>指针域</strong>：存储直接后继的位置(<strong>p-&gt;next</strong>)</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-10.jpg" height=120 /></center>

<p><strong>空链表</strong></p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/20230812133616.png" height=120 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 线性表的单链表存储结构 */<br>typedef struct Node<br>&#123;<br>    ElemType data;<br>    struct Node *next;<br>&#125; Node;<br>/* 定义LinkList */<br>typedef struct Node *LinkList;<br></code></pre></td></tr></table></figure>

<p><strong>单链表优缺点</strong></p>
<ol>
<li>无需连续存储单元</li>
<li>指针域会浪费空间</li>
<li>非随机存取，无法直接查找特定节点</li>
</ol>
<h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h4><ol>
<li>声明指针p指向头结点，初始化j&#x3D;1</li>
<li>j&lt;i时遍历链表，指针p不断向下移动，++j</li>
<li>p为空时，则i结点不存在</li>
<li>查找成功，则返回结点p的数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 初始条件：顺序线性表L已存在，1≤i≤<br>   ListLength(L) */<br>/* 操作结果：用e返回L中第i个数据元素的值 */<br>Status GetElem(LinkList L, int i, ElemType *e)<br>&#123;<br>    int j;<br>    LinkList p;            /* 声明一指针p */<br>    p = L-&gt;next;        /* 让p指向链表L的第个结点 */<br>    j = 1;                 /* j为计数器 */<br>    /* p不为空且计数器j还没有等于i时，循环继续 */<br>    while (p &amp;&amp; j &lt; i)    <br>    &#123;<br>        p = p-&gt;next;    /* 让p指向下一个结点 */<br>        ++j;<br>    &#125;<br>    if (!p || j &gt; i)<br>        return ERROR;      /* 第i个结点不存在 */<br>    *e = p-&gt;data;       /* 取第i个结点的数据 */<br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p><strong>单链表的插入</strong></p>
<center><table><tr>
<td><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-2.jpg" width=250 /></td>
<td><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-3.jpg" width=250 /></td></tr></table></center>

<p><strong>表头&#x2F;表尾的插入</strong></p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-4.jpg" width=500 /></center>

<ol>
<li>声明p指针指向头结点，初始化j&#x3D;1</li>
<li>j&lt;i时遍历链表，指针p不断向下移动，++j</li>
<li>p为空时，则i结点不存在</li>
<li>查找成功，则生成空结点s</li>
<li>s-&gt;data &#x3D; e</li>
<li>s-&gt;next &#x3D; p-&gt;next</li>
<li>p-&gt;next &#x3D; s</li>
<li>返回成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 初始条件：顺序线性表L已存在，1≤i≤<br>   ListLength(L)， */<br>/* 操作结果：在L中第i个结点位置之前插入新的数<br>   据元素e，L的长度加1 */<br>Status ListInsert(LinkList *L, int i, ElemType e)<br>&#123;<br>    int j;<br>    LinkList p, s;<br>    p = *L;<br>    j = 1;<br>    /* 寻找第i-1个结点 */<br>    while (p &amp;&amp; j &lt; i)                     <br>    &#123;<br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    /* 第i个结点不存在 */<br>    if (!p || j &gt; i)<br>        return ERROR;                      <br>    /* 生成新结点（C标准函数） */<br>    s = (LinkList)malloc(sizeof(Node));    <br>    s-&gt;data = e;<br>    /* 将p的后继结点赋值给s的后继 */<br>    s-&gt;next = p-&gt;next;                    <br>    /* 将s赋值给p的后继 */<br>    p-&gt;next = s;<br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-5.jpg" width=400 /></center>

<ol>
<li>声明p指针指向头结点，初始化j&#x3D;1</li>
<li>j&lt;i时遍历链表，指针p不断向下移动，++j</li>
<li>p为空时，则i结点不存在</li>
<li>查找成功，则q &#x3D; p-&gt;next</li>
<li>p-&gt;next &#x3D; q-&gt;next</li>
<li>e &#x3D; q-&gt;data</li>
<li>释放q结点</li>
<li>返回成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 初始条件：顺序线性表L已存在，1≤i≤<br>   ListLength(L) */<br>/* 操作结果：删除L的第i个结点，并用e返回其<br>   值，L的长度减1 */<br>Status ListDelete(LinkList *L, int i, ElemType *e)<br>&#123;<br>    int j;<br>    LinkList p, q;<br>    p = *L;<br>    j = 1;<br>    /* 遍历寻找第i-1个结点 */<br>    while (p-&gt;next &amp;&amp; j &lt; i)    <br>    &#123;<br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    /* 第i个结点不存在 */<br>    if (!(p-&gt;next) || j &gt; i)<br>        return ERROR;           <br>    q = p-&gt;next;<br>    /* 将q的后继赋值给p的后继 */<br>    p-&gt;next = q-&gt;next;          <br>    /* 将q结点中的数据给e */<br>    *e = q-&gt;data;               <br>    /* 让系统回收此结点，释放内存 */<br>    free(q);                    <br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="整表创建"><a href="#整表创建" class="headerlink" title="整表创建"></a>整表创建</h4><p><strong>头插法</strong></p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-9-1.jpg" width=400 /></center>

<ol>
<li>声明指针p和变量i</li>
<li>初始化空链表L</li>
<li>建立带头结点的空表(头结点指向NULL)</li>
<li>循环：<ol>
<li>生成新节点，并赋值给p</li>
<li>随机生成数赋值给p的数据域</li>
<li>将p插入到头结点与新结点之间</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 随机产生n个元素的值，建立带表头结点的单链<br>   线性表L（头插法） */<br>void CreateListHead(LinkList *L, int n)<br>&#123;<br>    LinkList p;<br>    int i;<br>    /* 初始化随机数种子 */<br>    srand(time(0));                            <br>    *L = (LinkList)malloc(sizeof(Node));<br>    /* 先建立一个带头结点的单链表 */<br>    (*L)-&gt;next = NULL;                         <br>    for (i = 0; i &lt; n; i++)<br>    &#123;<br>        /* 生成新结点 */<br>        p = (LinkList)malloc(sizeof(Node));    <br>        /* 随机生成100以内的数字 */<br>        p-&gt;data = rand() % 100 + 1;            <br>        p-&gt;next = (*L)-&gt;next;<br>        /* 插入到表头 */<br>        (*L)-&gt;next = p;                        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>尾插法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 随机产生n个元素的值，建立带表头结点的单链<br>线性表L（尾插法） */<br>void CreateListTail(LinkList *L, int n)<br>&#123;<br>    LinkList p,r;<br>    int i;<br>    /* 初始化随机数种子 */<br>    srand(time(0));                         <br>    /* 为整个线性表 */<br>    *L = (LinkList)malloc(sizeof(Node));    <br>    /* r为指向尾部的结点 */<br>    r = *L;                                 <br>    for (i = 0; i &lt; n; i++)<br>    &#123;<br>        /* 生成新结点 */<br>        p = (Node *)malloc(sizeof(Node));   <br>        /* 随机生成100以内的数字 */<br>        p-&gt;data = rand() % 100 + 1;         <br>        /* 将表尾终端结点的指针指向新结点 */<br>        r-&gt;next = p;                        <br>        /* 将当前的新结点定义为表尾终端结点 */<br>        r = p;                              <br>    &#125;<br>    /* 表示当前链表结束 */<br>    r-&gt;next = NULL;                         <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h4><ol>
<li>声明指针p和q</li>
<li>将头结点赋值给p</li>
<li>循环：<ol>
<li>将下一结点赋值给q</li>
<li>释放p</li>
<li>将q赋值给p</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 初始条件：顺序线性表L已存在，操作结果：将L<br>   重置为空表 */<br>Status ClearList(LinkList *L)<br>&#123;<br>    LinkList p, q;<br>    /* p指向第一个结点 */<br>    p = (*L)-&gt;next;       <br>    /* 没到表尾 */<br>    while (p)             <br>    &#123;<br>        q = p-&gt;next;<br>        free(p);<br>        p=q;<br>    &#125;<br>    /* 头结点指针域为空 */<br>    (*L)-&gt;next = NULL;    <br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>线性表</th>
<th>存储方式</th>
<th>时间性能</th>
<th>空间性能</th>
<th>适用</th>
</tr>
</thead>
<tbody><tr>
<td>顺序表</td>
<td>连续存储</td>
<td>查找O(1)<br>插入O(n)<br>删除O(n)</td>
<td>预分配空间</td>
<td>频繁查找，很少插入删除</td>
</tr>
<tr>
<td>单链表</td>
<td>链式存储</td>
<td>查找O(n)<br>插入O(n)<br>删除O(n)</td>
<td>自由分配空间</td>
<td>元素个数多，变化大</td>
</tr>
</tbody></table>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>静态链表</strong>：用数组描述的链表</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-1.jpg" height=150 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 线性表的静态链表存储结构 */<br>/* 假设链表的最大长度是1000 */<br>#define MAXSIZE 1000                     <br>typedef struct<br>&#123;<br>    ElemType data;<br>    /* 游标（Cursor），为0时表示无指向 */<br>    int cur;                             <br>&#125; Component, <br>  /* 对于不提供结构struct的程序设计语言，<br>     可以使用一对并行数组data和cur来处理。 */<br>  StaticLinkList[MAXSIZE];<br></code></pre></td></tr></table></figure>

<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-3.jpg" height=120 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 若备用空间链表非空，则返回分配的结点下标，<br>   否则返回0 */<br>int Malloc_SLL(StaticLinkList space)<br>&#123;<br>    /* 当前数组第一个元素的cur存的值， */<br>    /* 就是要返回的第一个备用空闲的下标 */<br>    int i = space[0].cur;               <br>    /* 由于要拿出一个分量来使用了，所以我们 */<br>    /* 就得把它的下一个分量用来做备用 */<br>    if (space[0].cur)<br>        space[0].cur = space[i].cur;    <br>    return i;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>静态链表的优缺点</strong></p>
<ol>
<li>插入删除只改游标，不动元素</li>
<li>无法确定表长</li>
<li>无法随机读取</li>
</ol>
<h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-3.jpg" height=120 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 若备用空间链表非空，则返回分配的结点下标，<br>   否则返回0 */<br>int Malloc_SLL(StaticLinkList space)<br>&#123;<br>    /* 当前数组第一个元素的cur存的值， */<br>    /* 就是要返回的第一个备用空闲的下标 */<br>    int i = space[0].cur;               <br>    /* 由于要拿出一个分量来使用了，所以我们 */<br>    /* 就得把它的下一个分量用来做备用 */<br>    if (space[0].cur)<br>        space[0].cur = space[i].cur;    <br>    return i;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 在L中第i个元素之前插入新的数据元素e  */<br>  Status ListInsert(StaticLinkList L, int i, ElemType e)<br>  &#123;<br>      int j, k, l;<br>      /* 注意k首先是最后一个元素的下标 */<br>      k = MAX_SIZE - 1;                   <br>      if (i &lt; 1 || i &gt; ListLength(L) + 1)<br>          return ERROR;<br>      /* 获得空闲分量的下标 */<br>      j = Malloc_SSL(L);                  <br>      if (j)<br>      &#123;<br>         /* 将数据赋值给此分量的data */<br>         L[j].data = e;                  <br>         /* 找到第i个元素之前的位置 */<br>         for (l = 1; l &lt;= i - 1; l++)    <br>             k = L[k].cur;<br>         /* 把第i个元素之前的cur赋值给新元素的cur */<br>         L[j].cur = L[k].cur;        <br>         /* 把新元素的下标赋值给第i个元素之前元素的cur */<br>         L[k].cur = j;                   <br>         return OK;<br>     &#125;<br>     return ERROR;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-4.jpg" height=80 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 删除在L中第i个数据元素e */<br>Status ListDelete(StaticLinkList L, int i)<br>&#123;<br>    int j, k;<br>    if (i &lt; 1 || i &gt; ListLength(L))<br>        return ERROR;<br>    k = MAX_SIZE - 1;<br>    for (j = 1; j &lt;= i - 1; j++)<br>        k = L[k].cur;<br>    j = L[k].cur;<br>    L[k].cur = L[j].cur;<br>    Free_SSL(L, j);<br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 将下标为k的空闲结点回收到备用链表 */<br>void Free_SSL(StaticLinkList space, int k)<br>&#123;<br>    /* 把第一个元素cur值赋给要删除的分量cur */<br>    space[k].cur = space[0].cur;    <br>    /* 把要删除的分量下标赋值给第一个元素的cur */<br>    space[0].cur = k;               <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 初始条件：静态链表L已存在。操作结果：返回L<br>   中数据元素个数 */<br>int ListLength(StaticLinkList L)<br>&#123;<br>    int j = 0;<br>    int i = L[MAXSIZE - 1].cur;<br>    while (i)<br>    &#123;<br>        i = L[i].cur;<br>        j++;<br>    &#125;<br>    return j;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>循环链表</strong>：将链表末端空指针改为指向头节点</p>
<p><strong>空循环链表</strong></p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-3.jpg" height=60 /></center>

<p><strong>非空循环链表</strong></p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-4.jpg" height=70 /></center>

<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-5.jpg" height=70 /></center>

<h3 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>合并链表</strong></p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-7.jpg" height=180 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 保存A表的头结点，即① */<br>p = rearA-&gt;next;                    <br>/*将本是指向B表的第一个结点（不是头结点） */<br>rearA-&gt;next = rearB-&gt;next-&gt;next;    <br>/* 赋值给reaA-&gt;next，即② */<br>q = rearB-&gt;next;<br>/* 将原A表的头结点赋值给rearB-&gt;next，即③ */<br>rearB-&gt;next = p;                    <br>/* 释放q */<br>free(q);<br></code></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>双向链表</strong>：单链表的每个结点中设置一个指向前驱的指针域</p>
<p><strong>空双向链表</strong></p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-3.jpg" height=80 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 线性表的双向链表存储结构 */<br>typedef struct DulNode<br>&#123;<br>    ElemType data;<br>    struct DuLNode *prior;    /* 直接前驱指针 */<br>    struct DuLNode *next;     /* 直接后继指针 */<br>&#125; DulNode, *DuLinkList;<br></code></pre></td></tr></table></figure>

<h3 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-5.jpg" height=200 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 把p赋值给s的前驱，如图中① */<br>s-&gt;prior = p;          <br>/* 把p-&gt;next赋值给s的后继，如图中② */<br>s-&gt;next = p-&gt;next;     <br>/* 把s赋值给p-&gt;next的前驱，如图中③ */<br>p-&gt;next-&gt;prior = s;    <br>/* 把s赋值给p的后继，如图中④ */<br>p-&gt;next = s;<br></code></pre></td></tr></table></figure>

<h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-6.jpg" height=150 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中① */<br>p-&gt;prior-&gt;next = p-&gt;next;     <br>/* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中② */<br>p-&gt;next-&gt;prior = p-&gt;prior;    <br>/* 释放结点 */<br>free(p);<br></code></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>栈</strong>：只允许在一段插入或删除的线性表(后进先出)</p>
<p>**进栈(push)**：栈的插入</p>
<p>**出栈(pop)**：栈的删除</p>
<p><strong>栈顶</strong>：允许插入或删除的一段</p>
<p><strong>栈底</strong>：不允许插入或删除的一段</p>
<p><strong>空栈</strong>：不含任何元素的空表</p>
<p><strong>顺序栈</strong>：采用顺序存储的栈</p>
<p><strong>共享栈</strong>：可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分<br>别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-5-1.jpg" height=100 /></center>

<p><strong>链栈</strong>：采用链式存储的栈</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-1.jpg" height=250 /></center>

<h3 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">InitStack(*S):    初始化操作，建立一个空栈S。<br>DestroyStack(*S): 若栈存在，则销毁它。<br>ClearStack(*S):   将栈清空。<br>StackEmpty(S):    若栈为空，返回true，否则返回false。<br>GetTop(S, *e):    若栈存在且非空，用e返回S的栈顶元素。<br>Push(*S, e):      若栈S存在，插入新元素e到栈S中并成为栈顶元素。<br>Pop(*S, *e):      删除栈S中栈顶元素，并用e返回其值。<br>StackLength(S):   返回栈S的元素个数。<br></code></pre></td></tr></table></figure>

<h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* SElemType类型根据实际情况而定，这里假设为int */<br>typedef int SElemType;    <br>typedef struct<br>&#123;<br>    SElemType data[MAXSIZE];<br>    /* 用于栈顶指针 */<br>    int top;              <br>&#125;SqStack;<br></code></pre></td></tr></table></figure>

<p>栈顶指针：S.top<br>初始时设置：S.top&#x3D;-1<br>栈顶元素：S.data[S.top]<br>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素<br>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1<br>栈空条件：S.top=&#x3D;-1<br>栈满条件：S.top=&#x3D;MaxSize-1<br>栈长：S.top+1</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void Initstack(SqStack &amp;S)&#123;<br>	S.top=-1;                //初始化栈顶指针<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bool StackEmpty(Sqstack S)&#123;<br>	if(S.top==-1)            //栈空<br>		return true;<br>	else                     //不空<br>		return false;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-2-2.jpg" height=200 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 插入元素e为新的栈顶元素 */<br>Status Push(SqStack *S, SElemType e)<br>&#123;<br>    /* 栈满 */<br>    if (S-&gt;top == MAXSIZE - 1)    <br>    &#123;<br>        return ERROR;<br>    &#125;<br>    /* 栈顶指针增加一 */<br>    S-&gt;top++;                     <br>    /* 将新插入元素赋值给栈顶空间 */<br>    S-&gt;data[S-&gt;top] = e;          <br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-2-3.jpg" height=200 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 若栈不空，则删除S的栈顶元素，用e返回其值，<br>   并返回OK；否则返回ERROR */<br>Status Pop(SqStack *S, SElemType *e)<br>&#123;<br>    if (S-&gt;top == -1)<br>        return ERROR;<br>    /* 将要删除的栈顶元素赋值给e */<br>    *e = S-&gt;data[S-&gt;top];    <br>    /* 栈顶指针减一 */<br>    S-&gt;top--;                <br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bool GetTop(SqStack S,ElemType &amp;x)&#123;<br>	if(S.top==-1)                   //栈空，报错<br>		return false;<br>	x=S.data[S.top];                //x记录栈顶元素<br>		return true;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 两栈共享空间结构 */<br>typedef struct<br>&#123;<br>    SElemType data[MAXSIZE];<br>    int top1;    /* 栈1栈顶指针 */<br>    int top2;    /* 栈2栈顶指针 */<br>&#125; SqDoubleStack;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 插入元素e为新的栈顶元素 */<br>Status Push(SqDoubleStack *S, SElemType e, <br>int stackNumber)<br>&#123;<br>    /* 栈已满，不能再push新元素了 */<br>    if (S-&gt;top1 + 1 == S-&gt;top2)    <br>        return ERROR;<br>    /* 栈1有元素进栈 */<br>    if (stackNumber == 1)          <br>        /* 若栈1则先top1+1后给数组元素赋值 */<br>        S-&gt;data[++S-&gt;top1] = e;    <br>    /* 栈2有元素进栈 */<br>    else if (stackNumber == 2)     <br>        /* 若栈2则先top2-1后给数组元素赋值 */<br>        S-&gt;data[--S-&gt;top2] = e;    <br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 若栈不空，则删除S的栈顶元素，用e返回其值，<br>   并返回OK；否则返回ERROR */<br>Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)<br>&#123;<br>    if (stackNumber == 1)<br>    &#123;<br>        /* 说明栈1已经是空栈，溢出 */<br>        if (S-&gt;top1 == -1)<br>            return ERROR;           <br>        /* 将栈1的栈顶元素出栈 */<br>        *e = S-&gt;data[S-&gt;top1--];    <br>    &#125;<br>    else if (stackNumber == 2)<br>    &#123;<br>        /* 说明栈2已经是空栈，溢出 */<br>        if (S-&gt;top2 == MAXSIZE)<br>            return ERROR;           <br>        /* 将栈2的栈顶元素出栈 */<br>        *e = S-&gt;data[S-&gt;top2++];    <br>    &#125;<br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct StackNode<br>&#123;<br>    SElemType data;<br>    struct StackNode *next;<br>&#125; StackNode, *LinkStackPtr;<br>typedef struct LinkStack<br>&#123;<br>    LinkStackPtr top;<br>    int count;<br>&#125; LinkStack;<br></code></pre></td></tr></table></figure>

<h4 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-2.jpg" height=250 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 插入元素e为新的栈顶元素 */<br>Status Push(LinkStack *S, SElemType e)<br>&#123;<br>    LinkStackPtr s <br>      = (LinkStackPtr)malloc(sizeof(StackNode));<br>    s-&gt;data = e;<br>    /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */<br>    s-&gt;next = S-&gt;top;    <br>    /* 将新的结点s赋值给栈顶指针，如图中② */<br>    S-&gt;top = s;          <br>    S-&gt;count++;<br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-3.jpg" height=250 /></center>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 若栈不空，则删除S的栈顶元素，用e返回其值，<br>   并返回OK；否则返回ERROR */<br>Status Pop(LinkStack *S, SElemType *e)<br>&#123;<br>    LinkStackPtr p;<br>    if (StackEmpty(*S))<br>        return ERROR;<br>    *e = S-&gt;top-&gt;data;<br>    /* 将栈顶结点赋值给p，如图③ */<br>    p = S-&gt;top;               <br>    /* 使得栈顶指针下移一位，指向后一结点，如图④ */<br>    S-&gt;top = S-&gt;top-&gt;next;    <br>    /* 释放结点p */<br>    free(p);                  <br>    S-&gt;count--;<br>    return OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>队列</strong>：只允许在一端插入，在另一端删除</p>
<center><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-10-1.jpg" height=100 /></center>

<p><strong>队头</strong>：允许删除的一端</p>
<p><strong>队尾</strong>：允许插入的一端</p>
<p><strong>空队列</strong>：不含任何元素的空表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>

<h3 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">InitQueue(*Q):    初始化操作，建立一个空队列Q。<br>DestroyQueue(*Q): 若队列Q存在，则销毁它。<br>ClearQueue(*Q):   将队列Q清空。<br>QueueEmpty(Q):    若队列Q为空，返回true，否则返回false。<br>GetHead(Q, *e):   若队列Q存在且非空，用e返回队列Q的队头元素。<br>EnQueue(*Q, e):   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。<br>DeQueue(*Q, *e):  删除队列Q中队头元素，并用e返回其值。<br>QueueLength(Q):   返回队列Q的元素个数<br></code></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Hexo/tags/IT/">IT</a><a class="post-meta__tags" href="/Hexo/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/Hexo/img/photo.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/Hexo/2023/08/01/C/" title="c语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">c语言</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-1"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">整表创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">整表删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.6.2.</span> <span class="toc-text">基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-6"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-5"><span class="toc-number">1.7.2.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-3"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-3"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.8.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-7"><span class="toc-number">1.8.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-6"><span class="toc-number">1.8.2.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%A0%88%E7%A9%BA"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">判栈空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88"><span class="toc-number">1.8.3.5.</span> <span class="toc-text">出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">1.8.3.6.</span> <span class="toc-text">读栈顶元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">1.8.3.7.</span> <span class="toc-text">共享栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">链式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88-1"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88-1"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">出栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.9.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-8"><span class="toc-number">1.9.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-7"><span class="toc-number">1.9.2.</span> <span class="toc-text">基本操作</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/Hexo/js/utils.js"></script><script src="/Hexo/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>